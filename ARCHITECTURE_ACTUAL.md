# Grassi Grosso: актуальное описание архитектуры (по коду)

Дата фиксации: 20.02.2026  
Источник: фактический код проекта (не `*.md` документация)

## 1) Коротко для менеджмента

Проект построен как быстрый маркетинговый сайт с несколькими страницами и единым backend API для обработки заявок из форм.

- Витрина: статические страницы (`index`, `hotels`, `dealers`, `catalog`, `documents`, `contacts`) + служебные (`privacy`, `terms`, `cookies`, `404`)
- Логика интерфейса: единый JS-модуль (`src/main.js`) с UX-функциями, анимациями (GSAP, Lenis), обработкой всех типов форм
- Backend: Node.js + Express (`server.cjs`) + модули `lib/` (антиспам, CORS), который:
  - принимает данные форм
  - проверяет антиспам (honeypot, лимиты по IP и длине полей)
  - валидирует и отправляет заявки в Telegram и Email
  - сохраняет недоставленные заявки в очередь с ретраями
  - в production раздаёт `dist`, в dev проксирует на Vite
- Деплой: Docker-контейнер (multi-stage), healthcheck `/health`; при необходимости — CI/CD и реверс-прокси (`nginx.conf` для Timeweb Cloud)

Ключевая характеристика решения: простота, быстрый запуск, минимум инфраструктуры.  
Подходит для текущей стадии продукта и быстрого вывода маркетинговых изменений.

## 2) Архитектура на уровне компонентов

### Frontend слой

- Технологии: Vite 7 + Vanilla JS + CSS + статические HTML
- Модель: Multi Page Application (MPA) с общим JS/CSS ядром
- Страницы (входы в `vite.config.mjs`):
  - Основные: `index.html`, `hotels.html`, `dealers.html`, `catalog.html`, `documents.html`, `contacts.html`
  - Служебные: `privacy.html`, `terms.html`, `cookies.html`, `404.html`
- JS-ядро (`src/main.js` на всех страницах):
  - анимации (GSAP, Lenis smooth scroll на десктопе), география/карта, preloader (шрифты + hero-медиа)
  - модальные окна, cookie-баннер, формы: контактные (`.contact-form`), коммерческое предложение, запрос каталога, запрос документов
  - все формы отправляют в `POST /api/submit` (URL задаётся через `VITE_API_URL`)
  - lazy-подгрузка карт (Yandex Maps API key через `VITE_YANDEX_MAPS_API_KEY` при сборке)

### Backend слой

- Технологии: Express (`server.cjs`), вспомогательные модули в `lib/`:
  - `lib/anti-spam.cjs` — honeypot (поля `website`/`url`/`homepage`), лимит отправок по IP за окно, минимальный интервал между отправками, блокировка с `Retry-After`, лимиты длины полей (имя, телефон, email, комментарий)
  - `lib/cors-config.cjs` — белый список origins (`CORS_ALLOWED_ORIGINS`), методы GET/POST/OPTIONS
- Функции сервера:
  - API заявок: `POST /api/submit` (после антиспам-проверки и валидации name/phone)
  - сервисные: `GET /health` (статус, размер очереди, наличие каналов), в non-production: `/api/test`, `/api/get-chat-id`, `GET /api/smtp-diag`
  - в production раздаёт `dist` (статику + fallback по пути и `*.html`, 404 → `404.html` или `index.html`)
  - в dev проксирует не-API запросы на Vite (localhost:5173)

### Интеграционный слой

- Telegram Bot API (уведомления о лидах)
- SMTP через `nodemailer` (дублирование лидов по email)
- Очередь `Queue + Retry` для повторной доставки при недоступности каналов
- Диагностический endpoint SMTP: `GET /api/smtp-diag`

### Инфраструктурный слой

- `Dockerfile` (multi-stage):
  - Stage 1: Node 22, `npm ci` + `npm run build`; опционально `VITE_YANDEX_MAPS_API_KEY` через build-arg
  - Stage 2: Node 22-slim, только production-зависимости; копируются `server.cjs`, `lib/`, `dist/`
- **Ключ Yandex Maps (`VITE_YANDEX_MAPS_API_KEY`):**
  - В **git не попадает**: `.env` в `.gitignore`, файл не коммитится.
  - В **контекст Docker не попадает**: `.dockerignore` исключает `.env`, при сборке образа ключ передаётся только через `--build-arg VITE_YANDEX_MAPS_API_KEY=...` на проде.
  - **Локально**: ключ берётся из `.env` при `npm run dev` или `npm run build` (Vite читает `VITE_*` из окружения и из `.env` в корне).
  - В **клиентском бандле** (`dist/assets/*.js`) ключ оказывается после сборки — это нормально для ключей карт (браузеру он нужен). В репозиторий не коммитится сама сборка (`dist` в `.gitignore`).
- Healthcheck: HTTP GET `/health` (интервал 10s, timeout 3s, start-period 20s)
- `nginx.conf`: реверс-прокси для Timeweb Cloud — статика из `/app/dist`, `/api/` проксируется на Node (переменная `${PORT}`)
- CI/CD: в репозитории пайплайн не описан; при необходимости настраивается отдельно (автодеплой после push)

## 3) Как устроен поток данных из форм

1. Пользователь заполняет форму на странице (`.contact-form` или форма запроса каталога/документов/КП).  
2. `src/main.js` валидирует имя, телефон, email (если нужен), согласие на ПДн.  
3. Фронтенд отправляет JSON в `POST /api/submit` (`fetch`, URL из `VITE_API_URL`).  
4. `server.cjs` нормализует payload лида; антиспам (`lib/anti-spam.cjs`) проверяет honeypot, лимиты по IP и длине полей — при провале возврат `429` и `Retry-After`.  
5. Заявка отправляется в **Telegram (primary)** и дополнительно в **Email (secondary)**.  
6. Если оба канала недоступны, заявка ставится в очередь на повторные попытки.  
7. Клиент получает статус доставки (`200` или `202 queued_retry`).

Поля заявки (в `normalizeLeadPayload`): `name`, `phone`, `comment`, `email`, `city`, `page`.

## 4) Текущая схема доставки лидов (реализовано)

- Режим 1: `Telegram primary`
- Режим 2: `Email secondary` (параллельное дублирование)
- Режим 3: `Queue + Retry` для гарантированной доставки

Особенности текущей реализации:

- Успех фиксируется, если сработал хотя бы один канал доставки.
- При недоступности обоих каналов API возвращает `202`, а заявка сохраняется в очередь.
- Очередь хранится на диске (`QUEUE_FILE_PATH`) и обрабатывается фоновым воркером по интервалу.

## 5) Почему текущая архитектура эффективна

- Быстрый time-to-market: мало слоев, минимум операционной сложности.
- Предсказуемая эксплуатация: один Node.js сервис закрывает API и раздачу фронта.
- Быстрые релизы: автодеплой через CI/CD сокращает ручные операции.
- Повышенная надежность лидов: дублирование каналов + персистентная очередь ретраев.
- Легкая масштабируемость по этапам: можно добавлять интеграции без полной переработки фронта.
- Хорошая база для CRO/маркетинга: страницы и формы можно быстро обновлять.
- Прозрачный деплой через Docker и healthcheck.

### 5.1) Почему лоадер работает стабильно и без визуальных артефактов

- Лоадер не «слепой»: снимается только после готовности критичных шрифтов и hero-медиа (`waitForFonts` + `waitForHeroMedia`).
- Есть защитные таймауты и fallback-ветка: UI не залипает при проблемах сети/ресурсов.
- Снижен риск layout shift: контент показывается после загрузки ключевых шрифтов (`body.fonts-loaded`).
- Видео не стартуют массово сразу: autoplay запускается через `IntersectionObserver`, только когда элемент реально видим.
- Поддержана отложенная загрузка источника видео (`data-src`) без избыточного раннего трафика.

### 5.2) Почему схема хранения и отдачи изображений эффективна

- Используется `<picture>` с fallback-цепочкой `AVIF -> WEBP -> PNG`: современная компрессия + совместимость.
- Для большинства ключевых изображений есть `1x/2x` варианты через `srcset`.
- Для тяжёлых каталоговых карточек есть дополнительные облегчённые версии (`@0.5x`) для экономии трафика.
- Нейминг ассетов системный и предсказуемый (например `name`, `name@2x`, `name@0.5x`), это упрощает поддержку.
- На этапе build Vite выпускает хешированные ассеты, что упрощает кеш-инвалидацию и снижает риск «старых» файлов у клиентов.

### 5.3) Почему эти решения проходят peer-review
- Решения приняты не только под happy path, но и под реальные сбои (два канала доставки + очередь + retry backoff).
- Производительность решается системно, а не точечно: контролируемый preloader, правильная медиаматрица форматов, ленивый autoplay.
- Эксплуатация продумана: healthcheck, SMTP-диагностика, диагностируемые env-настройки.
- Архитектура эволюционная: без переписывания можно наращивать кеширование и слой данных (PocketBase).

## 6) Ограничения текущего этапа (честно для техверификации)

- Монолитный фронтенд-скрипт (`src/main.js`) усложняет поддержку при росте функционала.
- Нет централизованного хранилища заявок (пока интеграционный канал, а не CRM/БД).
- В `dist` высокий вес медиа-контента; без кеширования и оптимизации это влияет на TTFB/LCP.

## 7) Дальнейшее развитие (после текущей реализации доставки)

### Шаг 1: кеширование для производительности

Цель: ускорить загрузку и снизить нагрузку.

- HTTP-кеш заголовки для статики (долгий TTL для хешированных ассетов).
- Компрессия (gzip/brotli) на уровне прокси/платформы.
- Кеширование тяжелых публичных ресурсов (изображения/видео/шрифты) на стороне приложения/прокси, без CDN. Мы В Российской Федерации.
- Политики `Cache-Control` и `ETag` для predictable invalidation.

Ожидаемый эффект: быстрее первый экран, меньше инфраструктурных затрат, стабильнее UX на мобильных сетях.

### Шаг 2: «умная» база на PocketBase (JS SDK) с минимальным администрированием

Цель: перейти от канала уведомлений к полноценной системе данных.

- Использовать PocketBase как слой данных и администрирования, с интеграцией через JS SDK.
- Первый шаг внедрения: администрирование коллекций в PocketBase, остальной контент и страницы остаются статическими.
- Далее хранить лиды, статусы доставки, источник, UTM/страницу, SLA-метрики в коллекциях.
- Добавить базовые правила доступа, аудит изменений и операционные отчеты.

Ожидаемый эффект: меньше ручного администрирования, прозрачная отчетность, база для аналитики.

## 8) Рекомендованная целевая схема (текущее состояние + следующие шаги)

`Browser Forms -> API (Express) -> Telegram(primary) + Email(secondary) -> Queue/Retry(if needed)`  
`Next: Queue/Worker + PocketBase`  
`Static/Media -> App/Proxy Cache Policy -> Browser`

Это эволюционный путь без «переписывания с нуля»: текущая архитектура позволяет внедрять изменения поэтапно.

## 9) Где это подтверждено в коде

- Frontend: `src/main.js`, `src/style.css`; страницы с формами: `hotels.html`, `dealers.html`, `contacts.html`, `documents.html`, `catalog.html` (и др., где есть `.contact-form` или формы запроса каталога/документов/КП)
- API и заявки: `server.cjs` (нормализация лида, Telegram/Email, очередь, ретраи)
- Антиспам: `lib/anti-spam.cjs`; CORS: `lib/cors-config.cjs`
- SMTP-диагностика: `GET /api/smtp-diag` в `server.cjs` (только при `NODE_ENV !== 'production'`)
- Сборка multi-page: `vite.config.mjs` (все HTML-входы и proxy `/api` на :3000)
- Контейнеризация: `Dockerfile`; реверс-прокси: `nginx.conf`
