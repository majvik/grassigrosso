# Grassi Grosso: актуальное описание архитектуры (по коду)

Дата фиксации: 17.02.2026  
Источник: фактический код проекта (не `*.md` документация)

## 1) Коротко для менеджмента

Проект построен как быстрый маркетинговый сайт с несколькими страницами и единым backend API для обработки заявок из форм.

- Витрина: статические страницы (`index`, `hotels`, `dealers`, `catalog`, `documents`, `contacts`)
- Логика интерфейса: единый JS-модуль с UX-функциями и обработкой форм
- Backend: Node.js + Express, который:
  - принимает данные форм
  - валидирует и отправляет заявки в Telegram и Email
  - сохраняет недоставленные заявки в очередь с ретраями
  - отдает собранный фронтенд в production
- Доставка изменений: автодеплой через CI/CD
- Деплой: Docker-контейнер, healthcheck `/health`

Ключевая характеристика решения: простота, быстрый запуск, минимум инфраструктуры.  
Это подходит для текущей стадии продукта и быстрого вывода маркетинговых изменений.

## 2) Архитектура на уровне компонентов

### Frontend слой

- Технологии: Vite + Vanilla JS + CSS + статические HTML
- Модель: Multi Page Application (MPA), но с общим JS/CSS ядром
- Основные страницы:
  - `index.html`
  - `hotels.html`
  - `dealers.html`
  - `catalog.html`
  - `documents.html`
  - `contacts.html`
- JS-ядро:
  - `src/main.js` подключается на всех страницах
  - содержит анимации, поведение UI, модальные окна, работу с формами, lazy-подгрузку карт

### Backend слой

- Технологии: Express (`server.cjs`)
- Функции:
  - API endpoint для заявок: `POST /api/submit`
  - сервисные endpoint-ы: `/health`, `/api/test`, `/api/get-chat-id`
  - в production раздает `dist` и поддерживает fallback на `index.html`
  - в dev проксирует не-API запросы в Vite dev server

### Интеграционный слой

- Telegram Bot API (уведомления о лидах)
- SMTP через `nodemailer` (дублирование лидов по email)
- Очередь `Queue + Retry` для повторной доставки при недоступности каналов
- Диагностический endpoint SMTP: `GET /api/smtp-diag`

### Инфраструктурный слой

- `Dockerfile` с multi-stage сборкой:
  - Stage 1: сборка фронтенда
  - Stage 2: runtime Node.js с production-зависимостями
- CI/CD-пайплайн с автоматическим деплоем после обновлений
- Healthcheck на `/health`
- Для реверс-проксирования предусмотрен `nginx.conf` (для платформы Timeweb Cloud)

## 3) Как устроен поток данных из форм

1. Пользователь заполняет форму на странице (`.contact-form`).  
2. `src/main.js` валидирует имя, телефон, email (если указан), согласие на ПДн.  
3. Фронтенд отправляет JSON в `POST /api/submit` (`fetch`).  
4. `server.cjs` собирает payload лида.  
5. Заявка отправляется в **Telegram (primary)** и дополнительно в **Email (secondary)**.  
6. Если оба канала недоступны, заявка ставится в очередь на повторные попытки.  
7. Клиент получает статус доставки (`200` или `202 queued_retry`).

Поля заявки: `name`, `phone`, `comment`, `email`, `city`, `company`, `page`.

## 4) Текущая схема доставки лидов (реализовано)

- Режим 1: `Telegram primary`
- Режим 2: `Email secondary` (параллельное дублирование)
- Режим 3: `Queue + Retry` для гарантированной доставки

Особенности текущей реализации:

- Успех фиксируется, если сработал хотя бы один канал доставки.
- При недоступности обоих каналов API возвращает `202`, а заявка сохраняется в очередь.
- Очередь хранится на диске (`QUEUE_FILE_PATH`) и обрабатывается фоновым воркером по интервалу.

## 5) Почему текущая архитектура эффективна

- Быстрый time-to-market: мало слоев, минимум операционной сложности.
- Предсказуемая эксплуатация: один Node.js сервис закрывает API и раздачу фронта.
- Быстрые релизы: автодеплой через CI/CD сокращает ручные операции.
- Повышенная надежность лидов: дублирование каналов + персистентная очередь ретраев.
- Легкая масштабируемость по этапам: можно добавлять интеграции без полной переработки фронта.
- Хорошая база для CRO/маркетинга: страницы и формы можно быстро обновлять.
- Прозрачный деплой через Docker и healthcheck.

### 5.1) Почему лоадер работает стабильно и без визуальных артефактов

- Лоадер не «слепой»: снимается только после готовности критичных шрифтов и hero-медиа (`waitForFonts` + `waitForHeroMedia`).
- Есть защитные таймауты и fallback-ветка: UI не залипает при проблемах сети/ресурсов.
- Снижен риск layout shift: контент показывается после загрузки ключевых шрифтов (`body.fonts-loaded`).
- Видео не стартуют массово сразу: autoplay запускается через `IntersectionObserver`, только когда элемент реально видим.
- Поддержана отложенная загрузка источника видео (`data-src`) без избыточного раннего трафика.

### 5.2) Почему схема хранения и отдачи изображений эффективна

- Используется `<picture>` с fallback-цепочкой `AVIF -> WEBP -> PNG`: современная компрессия + совместимость.
- Для большинства ключевых изображений есть `1x/2x` варианты через `srcset`.
- Для тяжёлых каталоговых карточек есть дополнительные облегчённые версии (`@0.5x`) для экономии трафика.
- Нейминг ассетов системный и предсказуемый (например `name`, `name@2x`, `name@0.5x`), это упрощает поддержку.
- На этапе build Vite выпускает хешированные ассеты, что упрощает кеш-инвалидацию и снижает риск «старых» файлов у клиентов.

### 5.3) Почему эти решения проходят peer-review
- Решения приняты не только под happy path, но и под реальные сбои (два канала доставки + очередь + retry backoff).
- Производительность решается системно, а не точечно: контролируемый preloader, правильная медиаматрица форматов, ленивый autoplay.
- Эксплуатация продумана: healthcheck, SMTP-диагностика, диагностируемые env-настройки.
- Архитектура эволюционная: без переписывания можно наращивать кеширование и слой данных (PocketBase).

## 6) Ограничения текущего этапа (честно для техверификации)

- Монолитный фронтенд-скрипт (`src/main.js`) усложняет поддержку при росте функционала.
- Нет централизованного хранилища заявок (пока интеграционный канал, а не CRM/БД).
- В `dist` высокий вес медиа-контента; без кеширования и оптимизации это влияет на TTFB/LCP.

## 7) Дальнейшее развитие (после текущей реализации доставки)

### Шаг 1: кеширование для производительности

Цель: ускорить загрузку и снизить нагрузку.

- HTTP-кеш заголовки для статики (долгий TTL для хешированных ассетов).
- Компрессия (gzip/brotli) на уровне прокси/платформы.
- Кеширование тяжелых публичных ресурсов (изображения/видео/шрифты) на стороне приложения/прокси, без CDN. Мы В Российской Федерации.
- Политики `Cache-Control` и `ETag` для predictable invalidation.

Ожидаемый эффект: быстрее первый экран, меньше инфраструктурных затрат, стабильнее UX на мобильных сетях.

### Шаг 2: «умная» база на PocketBase (JS SDK) с минимальным администрированием

Цель: перейти от канала уведомлений к полноценной системе данных.

- Использовать PocketBase как слой данных и администрирования, с интеграцией через JS SDK.
- Первый шаг внедрения: администрирование коллекций в PocketBase, остальной контент и страницы остаются статическими.
- Далее хранить лиды, статусы доставки, источник, UTM/страницу, SLA-метрики в коллекциях.
- Добавить базовые правила доступа, аудит изменений и операционные отчеты.

Ожидаемый эффект: меньше ручного администрирования, прозрачная отчетность, база для аналитики.

## 8) Рекомендованная целевая схема (текущее состояние + следующие шаги)

`Browser Forms -> API (Express) -> Telegram(primary) + Email(secondary) -> Queue/Retry(if needed)`  
`Next: Queue/Worker + PocketBase`  
`Static/Media -> App/Proxy Cache Policy -> Browser`

Это эволюционный путь без «переписывания с нуля»: текущая архитектура позволяет внедрять изменения поэтапно.

## 9) Где это подтверждено в коде

- Frontend логика и формы: `src/main.js`
- Страницы с формами: `hotels.html`, `dealers.html`, `contacts.html`
- API и отправка заявок: `server.cjs`
- SMTP диагностика: `GET /api/smtp-diag` в `server.cjs`
- Сборка multi-page: `vite.config.mjs`
- Контейнеризация и healthcheck: `Dockerfile`
