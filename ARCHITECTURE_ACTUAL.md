# Grassi Grosso: актуальное описание архитектуры (по коду)

Дата фиксации: 16.02.2026  
Источник: фактический код проекта (не `*.md` документация)

## 1) Коротко для менеджмента

Проект построен как быстрый маркетинговый сайт с несколькими страницами и единым backend API для обработки заявок из форм.

- Витрина: статические страницы (`index`, `hotels`, `dealers`, `catalog`, `documents`, `contacts`)
- Логика интерфейса: единый JS-модуль с UX-функциями и обработкой форм
- Backend: Node.js + Express, который:
  - принимает данные форм
  - валидирует и отправляет уведомление в Telegram
  - отдает собранный фронтенд в production
- Доставка изменений: автодеплой через CI/CD
- Деплой: Docker-контейнер, healthcheck `/health`

Сильная сторона решения: простота, быстрый запуск, минимум инфраструктуры.  
Это подходит для текущей стадии продукта и быстрого вывода маркетинговых изменений.

## 2) Архитектура на уровне компонентов

### Frontend слой

- Технологии: Vite + Vanilla JS + CSS + статические HTML
- Модель: Multi Page Application (MPA), но с общим JS/CSS ядром
- Основные страницы:
  - `index.html`
  - `hotels.html`
  - `dealers.html`
  - `catalog.html`
  - `documents.html`
  - `contacts.html`
- JS-ядро:
  - `src/main.js` подключается на всех страницах
  - содержит анимации, поведение UI, модальные окна, работу с формами, lazy-подгрузку карт

### Backend слой

- Технологии: Express (`server.cjs`)
- Функции:
  - API endpoint для заявок: `POST /api/submit`
  - сервисные endpoint-ы: `/health`, `/api/test`, `/api/get-chat-id`
  - в production раздает `dist` и поддерживает fallback на `index.html`
  - в dev проксирует не-API запросы в Vite dev server

### Интеграционный слой

- На текущий момент в коде реализована доставка заявок в Telegram Bot API.
- Формат: структурированное сообщение с полями формы и страницей источника.
- Защита формата: экранирование спецсимволов Markdown перед отправкой.

### Инфраструктурный слой

- `Dockerfile` с multi-stage сборкой:
  - Stage 1: сборка фронтенда
  - Stage 2: runtime Node.js с production-зависимостями
- CI/CD-пайплайн с автоматическим деплоем после обновлений
- Healthcheck на `/health`
- Для реверс-проксирования предусмотрен `nginx.conf` (опционально для платформы)

## 3) Как устроен поток данных из форм

1. Пользователь заполняет форму на странице (`.contact-form`).  
2. `src/main.js` валидирует имя, телефон, email (если указан), согласие на ПДн.  
3. Фронтенд отправляет JSON в `POST /api/submit` (`fetch`).  
4. `server.cjs` собирает и форматирует сообщение.  
5. Сообщение отправляется в Telegram (бот + chat id из окружения).  
6. Клиент получает статус и показывает пользователю результат отправки.

Поля заявки: `name`, `phone`, `comment`, `email`, `city`, `company`, `page`.

## 4) Статус по отправке писем из форм (важно)

Ваш текущий вектор развития учтен:

- Сейчас по коду в production-ветке реализована отправка заявок в Telegram.
- Логика форм уже готова для расширения канала доставки.
- Ближайшее расширение: добавить почтовый канал (SMTP/API-провайдер) параллельно Telegram или с fallback-стратегией.

Рекомендуемый практичный режим запуска почты:

- Режим 1: `Telegram + Email` (дублирование критичных лидов)
- Режим 2: `Email primary, Telegram fallback`
- Режим 3: `Queue + Retry` для гарантированной доставки

## 5) Почему текущая архитектура сильная

- Быстрый time-to-market: мало слоев, минимум операционной сложности.
- Предсказуемая эксплуатация: один Node.js сервис закрывает API и раздачу фронта.
- Быстрые релизы: автодеплой через CI/CD сокращает ручные операции.
- Легкая масштабируемость по этапам: можно добавлять интеграции без полной переработки фронта.
- Хорошая база для CRO/маркетинга: страницы и формы можно быстро обновлять.
- Прозрачный деплой через Docker и healthcheck.

## 6) Ограничения текущего этапа (честно для техверификации)

- Монолитный фронтенд-скрипт (`src/main.js`) усложняет поддержку при росте функционала.
- Нет централизованного хранилища заявок (пока интеграционный канал, а не CRM/БД).
- Нет очереди задач и повторных попыток отправки на уровне инфраструктуры.
- В `dist` высокий вес медиа-контента; без кеширования и оптимизации это влияет на TTFB/LCP.

## 7) План развития, который уже закладывается

### Этап A: отправка писем из форм (текущий этап)

Цель: повысить надежность и операционную управляемость лидов.

- Добавить email-канал доставки заявок.
- Ввести стратегию резервирования (fallback), чтобы лид не терялся.
- Добавить трекинг доставки (успех/ошибка по каждому каналу).

### Этап B: кеширование для производительности (следующий этап)

Цель: ускорить загрузку и снизить нагрузку.

- HTTP-кеш заголовки для статики (долгий TTL для хешированных ассетов).
- Компрессия (gzip/brotli) на уровне прокси/платформы.
- Кеширование тяжелых публичных ресурсов (изображения/видео/шрифты) на стороне приложения/прокси, без CDN.
- Политики `Cache-Control` и `ETag` для predictable invalidation.

Ожидаемый эффект: быстрее первый экран, меньше инфраструктурных затрат, стабильнее UX на мобильных сетях.

### Этап C: «умная» база на PocketBase (JS SDK) с минимальным администрированием

Цель: перейти от канала уведомлений к полноценной системе данных.

- Использовать PocketBase как слой данных и администрирования, с интеграцией через JS SDK.
- Первый шаг внедрения: администрирование коллекций в PocketBase, остальной контент и страницы остаются статическими.
- Далее хранить лиды, статусы доставки, источник, UTM/страницу, SLA-метрики в коллекциях.
- Добавить базовые правила доступа, аудит изменений и операционные отчеты.

Ожидаемый эффект: меньше ручного администрирования, прозрачная отчетность, база для аналитики и автоматизации продаж.

## 8) Рекомендованная целевая схема (после этапов A/B/C)

`Browser Forms -> API (Express) -> Queue/Worker -> Telegram + Email + PocketBase`  
`Static/Media -> App/Proxy Cache Policy -> Browser`

Это эволюционный путь без «переписывания с нуля»: текущая архитектура позволяет внедрять изменения поэтапно.

## 9) Где это подтверждено в коде

- Frontend логика и формы: `src/main.js`
- Страницы с формами: `hotels.html`, `dealers.html`, `contacts.html`
- API и отправка заявок: `server.cjs`
- Сборка multi-page: `vite.config.mjs`
- Контейнеризация и healthcheck: `Dockerfile`
